---
title: Fixing Exploits
date: 2024-02-24 06:30:00 -0600
categories: [OSCP]
tags: [oscp, pen200, offsec, certs]     # TAG names should always be lowercase
---
*The Fixing Exploits tools and tactics reviewed here are presented specifically in preparation for the OSCP exam per course suggestions and are by no means replacements for the OSCP training course, nor comprehensive guides for this step in the Kill Chain.*

# Fixing Exploits

Adjusting memory corruption and web app exploits require us to modify the socket option and application-specific paramaters, like URIs, cookies, etc.

## Fixing Memory Corruption Exploits

Memory corruption exploits like buffer overflows are a little more complicated and can be difficult to modify for our needs.

### Buffer Overflow Review

A buffer is an area in memory meant to store content that is often user-sent for processing later. Some buffers are dynamic in size and some are fixed/preallocated.

Buffer overflows occur when user-provided content writes beyond the stack limit and into the adjacent area of memory.

Memory corruption vulns occur in different parts of a program, like the stack (stores local functions' data and is fixed in size) or the heap (stores globally-accessible data and is dynamic in size).

The stack will often have local vars like buffers or integers.

```c
*buffer[16]*
...
strcpy(buffer, argv[1]);
```

The argument in the code above is only allocated 16 characters, but performs no checks before copying the user's input.

The return address is a memory address that stores the next function to be executed once the one running has completed. If the user's input is larger than the buffer, it could overwrite that return address. After the function ends, the ret instruction is executed, loading the return address inside the EIP/IRP, which is the instruction pointer responsible for keeping track of active code instructions... This means we may be able to take control of the program flow!

While we can test with arbitrary characters, attackers will typically rewrite the return address with a valid, mapped memory address that has the attacker's shellcode.

We typically want to overwrite the return address wit ha JMP ESP instruction to jump to the stack and run shellcode that we inject immediately following the beginning of our payload.

A stack-based overflow usually looks like this:
- create the large buffer to trigger the overflow
- overwrite a return address on the stack to take control of EIP
- include your payload in the buffer prepended by an optional NOP sled
- choose a valid return address instruction, like JPM ESP (or a different register) to redirect the execution flow to the payload.

One of the most reliable ways to find the return address ourselves is to clone the target environment locally in a VM and use a debugger on the vulnerable software to obtain the memory address of the return address instruction.

Be sure to exclude bad characters in your payload, meaning some ASCII or UNICODE chars break apps when we use them in payloads becayse they might be interpreted as conrol characters. \x00 is often a string terminator, for example, and could truncate our attack buffer.

### Importing and Examining the Exploit

Example:

```console
$ searchsploit "Sync Breeze Enterprise 10.0.28"

Sync Breeze Enterprise 10.0.28 - Denial of-Service (PoC) | windows/dos/43200.py
Sync Breeze Enterprise 10.0.28 - Remote Buffer Over | exploits/windows/remote/42928.py
Sync Breeze Enterprise 10.0.28 - Remote Buffer Over | exploits/windows/dos/42341.c
```

The last exploit listed above is coded in C. In summary:

```
offset    = "A" * 780 
JMP_ESP   =  "\x83\x0c\x09\x10"
shellcode = "\x90"*16 + msf_shellcode
exploit   = offset + JMP_ESP + shellcode
```

At offset 780, overwrite the instruction pointer with a JMP ESP located at memory addr 0x10090c83, append shellcode with 16 NOPs, and include the exploit buffer in the HTTP POST request.

The main differences between python and c that will impact us regard memory management and string operations. Scripting languages are executed through an interpreter, not compiled into a stand-alone exe. Because of this, we cannot run Python on a target where Python is not installed.

TIP: Perhaps consider using PyInstaller, which packages Python apps into stand-alone exes for various target OSs. It is usually best, though, to port the code by hand.

Python also makes it easier to concatenate a string:

```console
$ python
...
>>> string1 = "This is"
>>> string2 = " a test"
>>> string3 = string1 + string2

>>> print(string3)
This is a test
```

However, that is not allowed in a language like C, because there are more precautions required.

Copy the explout and inspect. In this case, we see headers showing us that the code was meant to be compiled on Windows. We could attempt to compile this on Windows, but we'll cross-compile on using Kali.

```console
$ searchsploit -m 42341

$ nano 42341
#include <inttypes.h>
#include <stdio.h>
#include <winsock2.h>
#include <windows.h>
```

In cases where we need to leverage exploits coded for a certain platform but only have a single attack environment (like Kali) we can use cross-compilers. A popular one is mingw-w64, which we can use to compile code into a Windows Portable Executable (PE) file.

```console
$ sudo apt install mingw-w64

// first, check for compilation errors
$ i686-w64-mingw32-gcc 42341.c -o syncbreeze_exploit.exe

// google search the erros and determine what you need to do
$ i686-w64-mingw32-gcc 42341.c -o syncbreeze_exploit.exe -lws2_32

$ ls -lah
42341.c syncbreeze_exploit.exe

$ wine syncbreeze_exploit.exe
```

The -l option instructs mingw-w64 to search for the ws2_32 DLL and include it in the final exe with static linking. In this exploit, the IP and port are hardcoded, so ensure the values are adjusted before compiling.
